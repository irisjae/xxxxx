var S = require ('s-js/dist/withsubclocks')
var L = require ('partial.lenses')
var R = require ('ramda')
var React
try {
	;React = require ('react') } catch {}



var T = _x => _fn_obj =>
        !! (_fn_obj .constructor === Array)
        ? !! equals ([]) (_fn_obj)
                ? _x
                : T (T (_x) (R .head (_fn_obj))) (R .tail (_fn_obj))
        : !! (_fn_obj .constructor === Function)
                ? _fn_obj (_x)
        : panic ('T requires a function as its input')
var Y = f => x => f (Y (f)) (x)
var $ = form =>
  x =>
    T (x) (form)
var apply = fn => arg_list =>
  fn .apply (null, arg_list)

var I = _x => _x
var K = _x => _ => _x
var not = _x => ! _x
var equals = R .equals

var impure = _fn => _fn
var jinx = _fn => {;_fn ()}


var panic = err => {;throw new Error (err)}
var panic_on = mandates =>
        _x => suppose (
              ( [ mandate, infraction ] = T (mandates) (R .find (([ charge, _ ]) => charge (_x))) || [] ) =>
              !! equals (infraction) (undefined) ? _x
              : jinx (_ => {;throw new Error (infraction)}) )



var suppose = fn_form => fn_form ()
var by = _meta_fn => x => T (x) (_meta_fn (x))




var faith = seed =>
	suppose (
        ( _truth = S .value (seed, equals)
	, _prayers = []
	, _praises = []
	, _confessions = []
	, _revelation = S .root (immortal => (//S .subclock (_ =>
		suppose (
		( revelation = S .data (true)
		, $__revelation = S .on (revelation, _ => {
			;_truth ($ (_prayers) (_show ()))
			;_prayers = [] }, undefined, true)
		) => 
		revelation )))
	, _repentance = S .root (immortal =>
		suppose (
		( repentance = S .data (true)
		, $__repentance = S .on (repentance, _ => {
			;_praises .forEach (_belief => {
				;_belief .count += 1 })
			;_confessions .forEach (_belief => {
				;_belief .count -= 1
				if (_belief .count === 0) {
					;_belief .ref = undefined
					;_belief .dispose () } })
			;_praises = []
			;_confessions = [] }, undefined, true)
		) =>
		repentance ))
        , _show = _ => S .sample (_truth)
        , _mark = _ => _truth ()
        , _please = request => {;_prayers = [ ..._prayers, request ] ;_revelation (true)}
	, _praise = _belief => {
		if (_praises .indexOf (_belief) === -1) {
			;_praises = [ ..._praises, _belief ]
			;_repentance (true)
			;S .cleanup (last => {
				if (! last) {
					;_confessions = [ ..._confessions, _belief ]
					;_repentance (true) } }) } }
	) => (
        { _show, _mark, _please, _praise } ) )
var belief = lens => source =>
	suppose (
        ( _belief = { count: 0, ref: undefined, dispose: undefined }
	, _communion = _ =>
		(praise (_belief) (source), _belief .ref || (_belief .ref = S .root (dispose => S .subclock (_ =>
			suppose (
			( communion = S .value (undefined, equals)
			, $__communion = S (_ => {
				;communion (L .get (lens) (mark (source))) })
			, $__disposal = jinx (_ => {;_belief .dispose = dispose})
			) =>
			communion ) )))
		) ()
        , _show = _ => L .get (lens) (show (source))
        , _mark = _ => _communion ()
        , _please = request => please (L .modify (lens) (request)) (source)
	, _praise = _belief => praise (_belief) (source)
	) => (
        { _show, _mark, _please, _praise } ) )




var show = by (({ _show }) => _show)
var mark = by (({ _mark }) => _mark)
var please = request => ({ _please }) => _please (request)

var praise = _belief => ({ _praise }) => _praise (_belief)



var L_ = new Proxy ({ chain: x => L .chain (x) ([]) }, { get: (o, x) => !! (x in o) ? o [x] : L [x] ([]) })



var calmm = type =>
	class extends gentle_calmm (type) {
		shouldComponentUpdate () {
			return false } }

var gentle_calmm = type =>
	!! (type .prototype && type .prototype .isReactComponent)
	? class extends type {
		render () {
			var self = this
			var real_render = _ => super .render ()
			var is = true
			
			;self .bury && self .bury () 
			return S .sample (S .root (bury => S (_ => {
				if (is) {
					;is = false
					;self .bury = _ => {;bury () ;self .bury = undefined}
					;S .cleanup (dying => {;dying || self .forceUpdate ()})
					return real_render () } }))) }
		componentWillUnmount () {
			var self = this

			;self .bury && self .bury ()
			;super .componentWillUnmount && super .componentWillUnmount () } }
	: gentle_calmm (class extends React.Component { render () { return type (this .props) }  })


module .exports =
	{ faith, belief 
	, show, mark, please 
	, calmm, gentle_calmm 
	, S 
	, T, Y, $, apply, I, K, not, equals, impure, jinx, panic, panic_on, suppose, by, L_ }
